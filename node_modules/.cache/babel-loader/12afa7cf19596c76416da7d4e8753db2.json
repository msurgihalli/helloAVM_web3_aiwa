{"ast":null,"code":"/*\n* Copyright (c) 2017-2018 Aion foundation.\n*\n*     This file is part of the aion network project.\n*\n*     The aion network project is free software: you can redistribute it \n*     and/or modify it under the terms of the GNU General Public License \n*     as published by the Free Software Foundation, either version 3 of \n*     the License, or any later version.\n*\n*     The aion network project is distributed in the hope that it will \n*     be useful, but WITHOUT ANY WARRANTY; without even the implied \n*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n*     See the GNU General Public License for more details.\n*\n*     You should have received a copy of the GNU General Public License\n*     along with the aion network project source files.  \n*     If not, see <https://www.gnu.org/licenses/>.\n*\n* Contributors:\n*     Aion foundation.\n*/\n\"use strict\";\n\nvar _get = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/get\");\n\nvar _possibleConstructorReturn = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/createClass\");\n\nvar utils = require('./coder-utils.js');\n\nvar TagNull = 0x32; // Used for Encoding Data Types and their Arguments for AVM Contracts\n\nvar Writer =\n/*#__PURE__*/\nfunction () {\n  function Writer() {\n    _classCallCheck(this, Writer);\n\n    this._data = utils.arrayify([]);\n  }\n\n  _createClass(Writer, [{\n    key: \"getData\",\n    value: function getData() {\n      return utils.hexlify(this._data);\n    } // The Byte Length of the Data\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._data.length;\n    }\n  }, {\n    key: \"writeByte\",\n    value: function writeByte(value) {\n      return this.writeBytes([value]);\n    } // Writes the bytes-representation of the data for encoders\n\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(bytes) {\n      this._data = utils.concat([this._data, bytes]);\n      return utils.arrayify(bytes).length;\n    } // Specificially used for writing Strings to ensure they do not exceed 64kb by\n    // shifting the binary representation 16 bits to the right and masking it for \n    // a total length of 64kb\n\n  }, {\n    key: \"writeLength\",\n    value: function writeLength(length) {\n      if (length > 0xffff) {\n        throw new Error(\"length out of bounds\");\n      }\n\n      return this.writeBytes([length >> 16, length & 0xff]);\n    }\n  }]);\n\n  return Writer;\n}(); // Used for Decoding Data Types and their Arguments for AVM Contracts\n\n\nvar Reader =\n/*#__PURE__*/\nfunction () {\n  function Reader(data) {\n    _classCallCheck(this, Reader);\n\n    utils.defineProperty(this, \"_data\", utils.arrayify(data));\n    this._offset = 0;\n  }\n\n  _createClass(Reader, [{\n    key: \"getConsumed\",\n    value: function getConsumed() {\n      return this._offset;\n    }\n  }, {\n    key: \"readByte\",\n    value: function readByte() {\n      return this.readBytes(1)[0];\n    } // Reads the byte-representation of the data used by decoders\n\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(count) {\n      var value = this._data.slice(this._offset, this._offset + count);\n\n      if (value.length !== count) {\n        throw new Error(\"out-of-bounds\");\n      }\n\n      this._offset += count;\n      return new Uint8Array(value);\n    }\n  }, {\n    key: \"readLength\",\n    value: function readLength() {\n      var bytes = this.readBytes(2);\n      return bytes[0] << 8 | bytes[1];\n    }\n  }]);\n\n  return Reader;\n}(); // Used for Data Types to enable them to Read/Write, Decode/Encode, as needed. \n// By default, all classes which inherit this will have a Decode and Encode method \n// which firsts confirms the tag passed in as being valid before performing their\n// unique conversions, depending on the class. Ex: the ByteCoder converts anything\n// with 6 bytes or less into a number through the BigNumber package. This works as \n// well with the CharCoder for the same reason.\n\n\nvar Coder =\n/*#__PURE__*/\nfunction () {\n  // The coder byte pattern tag\n  // The fully expanded type, including composite types:\n  //   - address, short[][], etc.\n  // The localName bound in the signature, in this example it is \"baz\":\n  //   - byte[] baz\n  function Coder(type, tag, localName) {\n    _classCallCheck(this, Coder);\n\n    this.type = type;\n    this.tag = tag;\n    this.localName = localName;\n  }\n\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message) {\n      return new Error(message);\n    }\n  }]);\n\n  return Coder;\n}(); // Used for Int, Short, Long, Byte, Boolean, and Char Data Types\n\n\nvar ByteCoder =\n/*#__PURE__*/\nfunction (_Coder) {\n  _inherits(ByteCoder, _Coder);\n\n  function ByteCoder(type, byteCount, tag, localName) {\n    var _this;\n\n    _classCallCheck(this, ByteCoder);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ByteCoder).call(this, type, tag, localName));\n    _this.byteCount = byteCount;\n    return _this;\n  } // As each byte is 8 bits, this takes a reader and it's data to decode \n  // its bytes through the BigNumber module\n\n\n  _createClass(ByteCoder, [{\n    key: \"decode\",\n    value: function decode(reader, array) {\n      if (array === null) {\n        var tag = reader.readByte();\n\n        if (tag !== this.tag) {\n          this._throwError(\"invalid tag\");\n        }\n      }\n\n      var value = utils.bigNumberify(reader.readBytes(this.byteCount)).fromTwos(this.byteCount * 8);\n      return value.toNumber();\n    } // Writes Bytes through a writer by first writing the tag in binary\n    // first, which would in theory be writing the length of the data\n    // first before then writing the actual bytes. This follows the\n    // structure of endian-encoding through this means\n\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value, array) {\n      if (value == null) {\n        this._throwError(\"cannot be null\");\n      }\n\n      var bytes = utils.padZeros(utils.arrayify(utils.bigNumberify(value).toTwos(this.byteCount * 8)), this.byteCount);\n      if (array === null) writer.writeByte(this.tag);\n      writer.writeBytes(bytes);\n    }\n  }]);\n\n  return ByteCoder;\n}(Coder); // Used for Boolean Data Types\n\n\nvar BooleanCoder =\n/*#__PURE__*/\nfunction (_ByteCoder) {\n  _inherits(BooleanCoder, _ByteCoder);\n\n  function BooleanCoder(type, tag, localName) {\n    _classCallCheck(this, BooleanCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BooleanCoder).call(this, type, 1, tag, localName));\n  } // Converts the decoded value to a boolean value \n  // through double-negation\n\n\n  _createClass(BooleanCoder, [{\n    key: \"decode\",\n    value: function decode(reader, array) {\n      return !!_get(_getPrototypeOf(BooleanCoder.prototype), \"decode\", this).call(this, reader, array);\n    } // Basically checks the value being passed in\n    // first as being either false (0x00) or true (0x01)\n    // and then passing in the binary representation of it\n\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value, array) {\n      _get(_getPrototypeOf(BooleanCoder.prototype), \"encode\", this).call(this, writer, !value ? 0x00 : 0x01, array);\n    }\n  }]);\n\n  return BooleanCoder;\n}(ByteCoder); // Used for handling char Data Types\n\n\nvar CharCoder =\n/*#__PURE__*/\nfunction (_ByteCoder2) {\n  _inherits(CharCoder, _ByteCoder2);\n\n  function CharCoder(type, tag, localName) {\n    _classCallCheck(this, CharCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CharCoder).call(this, type, 2, tag, localName));\n  } // Overrides the ByteCoder's decode method \n  // to read the char from ASCII after decoding\n\n\n  _createClass(CharCoder, [{\n    key: \"decode\",\n    value: function decode(reader, array) {\n      return String.fromCharCode(_get(_getPrototypeOf(CharCoder.prototype), \"decode\", this).call(this, reader, array));\n    } // Overrides the ByteCoder's encode method\n    // to write the char to ASCII before encoding.\n    // Also, it ensures that the value being encoded\n    // is only 1 character long as JavaScript is not\n    // a strongly typed language; ergo, value is a string\n\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value, array) {\n      if (value.length !== 1) {\n        throw new Error(\"char must be 1 char long\");\n      }\n\n      _get(_getPrototypeOf(CharCoder.prototype), \"encode\", this).call(this, writer, value.charCodeAt(0), array);\n    }\n  }]);\n\n  return CharCoder;\n}(ByteCoder); // Used to handle float and double Data Types\n\n\nvar FloatCoder =\n/*#__PURE__*/\nfunction (_Coder2) {\n  _inherits(FloatCoder, _Coder2);\n\n  function FloatCoder(type, byteCount, tag, localName) {\n    var _this2;\n\n    _classCallCheck(this, FloatCoder);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FloatCoder).call(this, type, tag, localName));\n    _this2.byteCount = byteCount;\n    return _this2;\n  } // Overides for the sake of building a DataView to get \n  // the float representation of the decoded result as\n  // JavaScript is not a strongly typed language\n\n\n  _createClass(FloatCoder, [{\n    key: \"decode\",\n    value: function decode(reader, array) {\n      if (array === null) {\n        var tag = reader.readByte();\n\n        if (tag !== this.tag) {\n          throw new Error(\"invalid tag\");\n        }\n      }\n\n      var view = new DataView(reader.readBytes(this.byteCount).buffer);\n\n      if (this.byteCount === 4) {\n        return view.getFloat32(0);\n      }\n\n      return view.getFloat64(0);\n    } // Floats are generated when the byteCount is 4 \n    // (32 bits; hence, setFloat32) while Doubles are \n    // generated when the byteCount is 8 (64 bits; hence, //\n    // setFloat64)\n\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value, array) {\n      if (array === null) writer.writeByte(this.tag);\n      var buffer = new ArrayBuffer(this.byteCount);\n      var view = new DataView(buffer);\n\n      if (this.byteCount === 4) {\n        view.setFloat32(0, value);\n      } else {\n        view.setFloat64(0, value);\n      }\n\n      writer.writeBytes(new Uint8Array(buffer, 0, this.byteCount));\n    }\n  }]);\n\n  return FloatCoder;\n}(Coder); // Specifically for Data Types that can be Null\n\n\nvar NullableCoder =\n/*#__PURE__*/\nfunction (_Coder3) {\n  _inherits(NullableCoder, _Coder3);\n\n  function NullableCoder() {\n    _classCallCheck(this, NullableCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NullableCoder).apply(this, arguments));\n  }\n\n  _createClass(NullableCoder, [{\n    key: \"decode\",\n    value: function decode(reader) {\n      var byte = reader.readByte();\n\n      if (byte === TagNull) {\n        return this.decodeNull(reader);\n      }\n\n      if (byte !== this.tag) {\n        throw new Error(\"invalid type\");\n      }\n\n      return this.decodeValue(reader);\n    } // Used specifically for decoding null values\n\n  }, {\n    key: \"decodeNull\",\n    value: function decodeNull(reader) {\n      var tag = reader.readByte();\n\n      if (tag !== this.tag) {\n        throw new Error(\"invalid null type\");\n      }\n\n      return null;\n    } // Determines whether to write the value as null or otherwise\n\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      if (value == null) {\n        writer.writeBytes([TagNull, this.tag]);\n      } else {\n        writer.writeByte(this.tag);\n        this.encodeValue(writer, value);\n      }\n    }\n  }]);\n\n  return NullableCoder;\n}(Coder); // Handling of the Address Data Type which is ultimately a String\n\n\nvar AddressCoder =\n/*#__PURE__*/\nfunction (_NullableCoder) {\n  _inherits(AddressCoder, _NullableCoder);\n\n  function AddressCoder(localName) {\n    _classCallCheck(this, AddressCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AddressCoder).call(this, \"address\", 0x22, localName));\n  } // Uses a utils specific method to confirm the value read is an Address format\n\n\n  _createClass(AddressCoder, [{\n    key: \"decodeValue\",\n    value: function decodeValue(reader) {\n      return utils.getAddress(utils.hexlify(reader.readBytes(32)));\n    } // Uses a utils specific method to ensure the value written is an Address format\n\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(writer, value) {\n      utils.getAddress(value);\n      writer.writeBytes(value);\n    }\n  }]);\n\n  return AddressCoder;\n}(NullableCoder); // Handling of String Data Type\n\n\nvar StringCoder =\n/*#__PURE__*/\nfunction (_NullableCoder2) {\n  _inherits(StringCoder, _NullableCoder2);\n\n  function StringCoder(localName) {\n    _classCallCheck(this, StringCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StringCoder).call(this, \"String\", 0x21, localName));\n  } // Reads the length of the string first before then takes\n  // the read output and converting it to a UTF8 String\n\n\n  _createClass(StringCoder, [{\n    key: \"decodeValue\",\n    value: function decodeValue(reader) {\n      var length = reader.readLength();\n      return utils.toUtf8String(reader.readBytes(length));\n    } // Converts the UTF8 String to bytes, then writes the \n    // length of the bytes followed by the bytes themselves\n\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(writer, value) {\n      var bytes = utils.toUtf8Bytes(value);\n      writer.writeLength(bytes.length);\n      writer.writeBytes(bytes);\n    }\n  }]);\n\n  return StringCoder;\n}(NullableCoder); // Handling of byte arrays (byte[])\n// Note: After finding a TagNull, the next byte will be \n// primitive array tag and needs to be read\n\n\nvar ByteArrayCoder =\n/*#__PURE__*/\nfunction (_ByteCoder3) {\n  _inherits(ByteArrayCoder, _ByteCoder3);\n\n  function ByteArrayCoder(type, byteCount, tag, localName) {\n    _classCallCheck(this, ByteArrayCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ByteArrayCoder).call(this, type, byteCount, tag, localName));\n  }\n\n  _createClass(ByteArrayCoder, [{\n    key: \"decode\",\n    value: function decode(reader) {\n      var tag = reader.readByte();\n\n      if (tag === TagNull) {\n        reader.readByte();\n        return null;\n      } else if (tag !== this.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      var length = reader.readLength();\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(_get(_getPrototypeOf(ByteArrayCoder.prototype), \"decode\", this).call(this, reader));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      var _this3 = this;\n\n      if (!Array.isArray(value)) {\n        this._throwError(\"has to be an array\");\n      }\n\n      writer.writeByte(this.tag);\n      writer.writeLength(value.length);\n      value.forEach(function (value) {\n        _get(_getPrototypeOf(ByteArrayCoder.prototype), \"encode\", _this3).call(_this3, writer, value, true);\n      });\n    }\n  }]);\n\n  return ByteArrayCoder;\n}(ByteCoder); // Handling of boolean arrays (boolean[])\n// Note: After finding a TagNull, the next byte will be \n// primitive array tag and needs to be read\n\n\nvar BooleanArrayCoder =\n/*#__PURE__*/\nfunction (_BooleanCoder) {\n  _inherits(BooleanArrayCoder, _BooleanCoder);\n\n  function BooleanArrayCoder(type, tag, localName) {\n    _classCallCheck(this, BooleanArrayCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BooleanArrayCoder).call(this, type, tag, localName));\n  }\n\n  _createClass(BooleanArrayCoder, [{\n    key: \"decode\",\n    value: function decode(reader) {\n      var tag = reader.readByte();\n\n      if (tag === TagNull) {\n        reader.readByte();\n        return null;\n      } else if (tag !== this.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      var length = reader.readLength();\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(_get(_getPrototypeOf(BooleanArrayCoder.prototype), \"decode\", this).call(this, reader));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      var _this4 = this;\n\n      if (!Array.isArray(value)) {\n        this._throwError(\"has to be an array\");\n      }\n\n      writer.writeByte(this.tag);\n      writer.writeLength(value.length);\n      value.forEach(function (value) {\n        _get(_getPrototypeOf(BooleanArrayCoder.prototype), \"encode\", _this4).call(_this4, writer, value, true);\n      });\n    }\n  }]);\n\n  return BooleanArrayCoder;\n}(BooleanCoder); // Used for handling char arrays (char[])\n// Note: After finding a TagNull, the next byte will be \n// primitive array tag and needs to be read\n\n\nvar CharArrayCoder =\n/*#__PURE__*/\nfunction (_CharCoder) {\n  _inherits(CharArrayCoder, _CharCoder);\n\n  function CharArrayCoder(type, tag, localName) {\n    _classCallCheck(this, CharArrayCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CharArrayCoder).call(this, type, tag, localName));\n  }\n\n  _createClass(CharArrayCoder, [{\n    key: \"decode\",\n    value: function decode(reader) {\n      var tag = reader.readByte();\n\n      if (tag === TagNull) {\n        reader.readByte();\n        return null;\n      } else if (tag !== this.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      var length = reader.readLength();\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(_get(_getPrototypeOf(CharArrayCoder.prototype), \"decode\", this).call(this, reader));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      var _this5 = this;\n\n      if (!Array.isArray(value)) {\n        this._throwError(\"has to be an array\");\n      }\n\n      writer.writeByte(this.tag);\n      writer.writeLength(value.length);\n      value.forEach(function (value) {\n        _get(_getPrototypeOf(CharArrayCoder.prototype), \"encode\", _this5).call(_this5, writer, value, true);\n      });\n    }\n  }]);\n\n  return CharArrayCoder;\n}(CharCoder); // Used to handle float and double arrays (float[] and double[])\n// Note: After finding a TagNull, the next byte will be \n// primitive array tag and needs to be read\n\n\nvar FloatArrayCoder =\n/*#__PURE__*/\nfunction (_FloatCoder) {\n  _inherits(FloatArrayCoder, _FloatCoder);\n\n  function FloatArrayCoder(type, byteCount, tag, localName) {\n    _classCallCheck(this, FloatArrayCoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FloatArrayCoder).call(this, type, byteCount, tag, localName));\n  }\n\n  _createClass(FloatArrayCoder, [{\n    key: \"decode\",\n    value: function decode(reader) {\n      var tag = reader.readByte();\n\n      if (tag === TagNull) {\n        reader.readByte();\n        return null;\n      } else if (tag !== this.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      var length = reader.readLength();\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(_get(_getPrototypeOf(FloatArrayCoder.prototype), \"decode\", this).call(this, reader));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(writer, value) {\n      var _this6 = this;\n\n      if (!Array.isArray(value)) {\n        this._throwError(\"has to be an array\");\n      }\n\n      writer.writeByte(this.tag);\n      writer.writeLength(value.length);\n      value.forEach(function (value) {\n        _get(_getPrototypeOf(FloatArrayCoder.prototype), \"encode\", _this6).call(_this6, writer, value, true);\n      });\n    }\n  }]);\n\n  return FloatArrayCoder;\n}(FloatCoder); // Handling of the string, address, and 2 dimensional (2D)\n// Arrays (string[], address[], and int[][], byte[][], etc)\n// Note: Only primitives (not string and address) can \n// be 2D Arrays, by first putting the outer-most array\n// as this type, and then the inner-most arrays as the\n// aforementioned array-types based on the primitive \n// ( ArrayCoder[ByteArrayCoder, ByteArrayCoder] )\n\n\nvar ArrayCoder =\n/*#__PURE__*/\nfunction (_NullableCoder3) {\n  _inherits(ArrayCoder, _NullableCoder3);\n\n  function ArrayCoder(coder, localName) {\n    var _this7;\n\n    _classCallCheck(this, ArrayCoder);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(ArrayCoder).call(this, coder.type + \"[]\", 0x31, localName));\n    _this7.coder = coder;\n    return _this7;\n  }\n\n  _createClass(ArrayCoder, [{\n    key: \"decodeNull\",\n    value: function decodeNull(reader) {\n      var tag = reader.readByte();\n\n      if (tag !== this.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      return null;\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(reader) {\n      var tag = reader.readByte();\n\n      if (tag !== this.coder.tag) {\n        throw new Error(\"invalid child tag\");\n      }\n\n      var length = reader.readLength();\n      var result = [];\n\n      for (var i = 0; i < length; i++) {\n        result.push(this.coder.decode(reader));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(writer, value) {\n      var _this8 = this;\n\n      writer.writeByte(this.coder.tag);\n      writer.writeLength(value.length);\n      value.forEach(function (value) {\n        if (value == null) {\n          writer.writeBytes([TagNull, _this8.coder.tag]);\n        } else {\n          _this8.coder.encode(writer, value);\n        }\n      });\n    }\n  }]);\n\n  return ArrayCoder;\n}(NullableCoder);\n\nmodule.exports = {\n  Reader: Reader,\n  Writer: Writer,\n  Coder: Coder,\n  ByteCoder: ByteCoder,\n  CharCoder: CharCoder,\n  ArrayCoder: ArrayCoder,\n  FloatCoder: FloatCoder,\n  StringCoder: StringCoder,\n  BooleanCoder: BooleanCoder,\n  AddressCoder: AddressCoder,\n  NullableCoder: NullableCoder,\n  ByteArrayCoder: ByteArrayCoder,\n  CharArrayCoder: CharArrayCoder,\n  FloatArrayCoder: FloatArrayCoder,\n  BooleanArrayCoder: BooleanArrayCoder\n};","map":null,"metadata":{},"sourceType":"script"}